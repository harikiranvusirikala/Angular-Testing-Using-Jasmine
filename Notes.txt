Introduction to Unit Testing:
===
Angular Unit Testing is crucial for ensuring the reliability, stability, and maintainability of your application. It helps catch bugs early, provides a safety net for code changes, and enhances code quality.
When using Jasmine for Angular unit testing, developers focus on testing individual components or services in isolation.

Test suites, created with the describe function, group related test cases. Individual test cases (specs) are defined using the it function. This structure helps organize and categorize tests based on functionality.

In Unit Testing, it's crucial to avoid reliance on external services, APIs, or databases. Instead, use test doubles like mocks or stubs to simulate the behavior of dependencies. This ensures that tests focus on the specific functionality of the unit being tested.

Jasmine provides various matchers, such as toEqual and toBe, for asserting expectations in test cases. These matchers allow developers to check if the actual result matches the expected result, ensuring the correctness of the tested functionality.

Some commonly used Jasmine matchers in Angular testing:
• toEqual: Tests for deep equality (used for objects and arrays).
• toBe: Tests for strict equality (used for primitives like numbers, strings, and booleans).
• toContain: Checks if an array or string contains a specific value.
• toBeTruthy: Checks if a value is truthy (not falsy).
• toBeFalsy: Checks if a value is falsy (not truthy).
• toBeGreaterThan, toBeLessThan, toBeCloseTo: Used for numeric comparisons.
expect(actualValue).toBeCloseTo(expectedValue, decimalPlaces);
• toThrow: Checks if a function throws an exception.
expect(() => someFunction()).toThrow();
• toHaveBeenCalled, toHaveBeenCalledWith: Checks if a spy (mocked function) has been called or called with specific arguments.
expect(spy).toHaveBeenCalled();
expect(spy).toHaveBeenCalledWith(arg1, arg2);

Assertion statements are written using the expect function. This function sets up the value or expression to be tested and is followed by a matcher function that performs the comparison between the actual and expected values.

Jasmine offers functions like beforeEach, afterEach, beforeAll, and afterAll for setting up and tearing down activities before and after test execution. These functions help create a consistent and controlled environment for testing.

Jasmine Global Functions for Setup and Teardown Activities:
• beforeEach
• afterEach
• beforeAll
• afterAll

Well-written unit tests contribute to better documentation, increased code confidence, and faster identification of issues. They lead to a more stable and reliable Angular application, providing assurance that the application functions as intended.
===



Setup:
===
Install following tools:
• Node.js (^18.15.0 || ^20.9.0) and npm (min version required 10.1.0) 
• Angular CLI (v16)
• Visual Studio Code

• Jasmine and Karma are essential tools for testing Angular applications. 
• Karma is the test runner for Angular applications. It will run your Jasmine tests in various browsers and provide you with test results in the terminal. You can also view test results in a browser window by default.
• Both Jasmine and Karma are already included by default when you create a new Angular project with the Angular CLI. 
• If you need to install them manually, you can do so with npm, using the below command;
$ npm install --save jasmine karma karma-jasmine karma-chrome-launcher

app.component.spec.ts
==
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'testing' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('testing');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, testing');
  });
});
==

login.service.spec.ts
==
import { TestBed } from '@angular/core/testing';

import { LoginService } from './login.service';

describe('LoginService', () => {
  let service: LoginService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(LoginService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
==

$ ng test

Jasmine is integrated seamlessly with the Angular CLI, so we don't need to perform additional setup steps for Jasmine itself beyond what's provided by the Angular CLI.
===

