Introduction to Unit Testing:
===
Angular Unit Testing is crucial for ensuring the reliability, stability, and maintainability of your application. It helps catch bugs early, provides a safety net for code changes, and enhances code quality.
When using Jasmine for Angular unit testing, developers focus on testing individual components or services in isolation.

Test suites, created with the describe function, group related test cases. Individual test cases (specs) are defined using the it function. This structure helps organize and categorize tests based on functionality.

In Unit Testing, it's crucial to avoid reliance on external services, APIs, or databases. Instead, use test doubles like mocks or stubs to simulate the behavior of dependencies. This ensures that tests focus on the specific functionality of the unit being tested.

Jasmine provides various matchers, such as toEqual and toBe, for asserting expectations in test cases. These matchers allow developers to check if the actual result matches the expected result, ensuring the correctness of the tested functionality.

Some commonly used Jasmine matchers in Angular testing:
• toEqual: Tests for deep equality (used for objects and arrays).
• toBe: Tests for strict equality (used for primitives like numbers, strings, and booleans).
• toContain: Checks if an array or string contains a specific value.
• toBeTruthy: Checks if a value is truthy (not falsy).
• toBeFalsy: Checks if a value is falsy (not truthy).
• toBeGreaterThan, toBeLessThan, toBeCloseTo: Used for numeric comparisons.
expect(actualValue).toBeCloseTo(expectedValue, decimalPlaces);
• toThrow: Checks if a function throws an exception.
expect(() => someFunction()).toThrow();
• toHaveBeenCalled, toHaveBeenCalledWith: Checks if a spy (mocked function) has been called or called with specific arguments.
expect(spy).toHaveBeenCalled();
expect(spy).toHaveBeenCalledWith(arg1, arg2);

Assertion statements are written using the expect function. This function sets up the value or expression to be tested and is followed by a matcher function that performs the comparison between the actual and expected values.

Jasmine offers functions like beforeEach, afterEach, beforeAll, and afterAll for setting up and tearing down activities before and after test execution. These functions help create a consistent and controlled environment for testing.

Jasmine Global Functions for Setup and Teardown Activities:
• beforeEach
• afterEach
• beforeAll
• afterAll

Well-written unit tests contribute to better documentation, increased code confidence, and faster identification of issues. They lead to a more stable and reliable Angular application, providing assurance that the application functions as intended.
===



Setup:
===
Install following tools:
• Node.js (^18.15.0 || ^20.9.0) and npm (min version required 10.1.0) 
• Angular CLI (v16)
• Visual Studio Code

• Jasmine and Karma are essential tools for testing Angular applications. 
• Karma is the test runner for Angular applications. It will run your Jasmine tests in various browsers and provide you with test results in the terminal. You can also view test results in a browser window by default.
• Both Jasmine and Karma are already included by default when you create a new Angular project with the Angular CLI. 
• If you need to install them manually, you can do so with npm, using the below command;
$ npm install --save jasmine karma karma-jasmine karma-chrome-launcher

app.component.spec.ts
==
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'testing' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('testing');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, testing');
  });
});
==

login.service.spec.ts
==
import { TestBed } from '@angular/core/testing';

import { LoginService } from './login.service';

describe('LoginService', () => {
  let service: LoginService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(LoginService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
==

$ ng test

Jasmine is integrated seamlessly with the Angular CLI, so we don't need to perform additional setup steps for Jasmine itself beyond what's provided by the Angular CLI.
===



Unit Testing Angular with Jasmine:
===
Below is the execution flow of the command ng test: 
• Angular CLI reads the configuration in the ‘angular.json’ file to determine which project and testing setup to use.
• Then Angular CLI sets up a test environment using TestBed. TestBed is a part of Angular's testing utilities that allow you to configure and create instances of components and services for testing.
• Karma, a popular test runner, to execute tests based on the settings in the 'karma.config.js' file. This configuration includes specifying which browsers to run the tests.
• Jasmine, the testing framework, takes over. It starts executing the test spec files(files with ‘.spec.ts' extensions) and runs the test suites and individual test cases.
• The ‘ng test’ command returns an exit status to indicate whether all tests passed or if there were failures of errors.

Angular Utilities:
TestBed
• It is the Angular testing utility that provides the mock of the application’s root module: @NgModule

configureTestingModule:
• This method configures the module environment for the component class to be tested.
• It is called within beforeEach so that TestBed resets itself to the base state before each spec runs.
• Note: the class to be tested is detached from its application module and is reattached to a dynamically constructed Angular test module.
• configureTestingModule method declares the component to be tested.

TestBed: createComponent
• It is the Angular testing utility method that returns the instance of the component class being tested.
• It returns the object of type Component Fixture.
• It closes the current TestBed instance for any further configurations.
• ComponentFixture is the handle provided on the instance of the component under test.

TestBed: detectChanges
• It is the Angular testing utility method that is responsible for detecting any angular change within a test.
• fixture.detectChanges() helps test to convey to Angular when to perform the detection.
• Note: Do not re-configure TestBed after calling createComponent.
• The TestBed.createComponent does not trigger change detection.

Testing an Angular component which has a service dependency:
A component-under-test doesn't have to be injected with real services as it is Unit Testing. A test-double or stub instead can be provided.

Eg: login.component.spec.ts
  const mockLoginService = jasmine.createSpyObj('LoginService',['getUsers']);
  const mockRouter = jasmine.createSpyObj('Router',['navigate'])
  await TestBed.configureTestingModule({
    declarations: [ LoginComponent ],
    imports:[FormsModule, ReactiveFormsModule,HttpClientTestingModule ],
    providers:[{provide: LoginService, useValue:mockLoginService},
    {provide:Router, useValue:mockRouter, FormBuilder}]
  })
    component.loginForm.controls['username'].setValue('user');
    component.loginForm.controls['password'].setValue('user');
    expect(component.loginForm.valid).toBeTruthy();
    expect(debugElement.nativeElement.querySelector('button[type="submit"]').disabled).toBeFalsy;

Testing an Angular component which has a life cycle method:
The ngOnInit() is a lifecycle hook in Angular that is called after the constructor is called and after the component's inputs have been initialized. It is used to perform any additional initialization that is required for the component.

Eg: products-list.component.spec.ts
    const loginServiceSpy = jasmine.createSpyObj('LoginService', ['getMobileData']);
    TestBed.configureTestingModule({
      declarations: [ProductsListComponent,SortPipe],
      imports:[HttpClientTestingModule,FormsModule,ReactiveFormsModule],
      providers:[{ provide: loginService, useValue: loginServiceSpy }]
    });
    fixture = TestBed.createComponent(ProductsListComponent);
    component = fixture.componentInstance;
    loginService = TestBed.inject(LoginService) as jasmine.SpyObj<LoginService>;
    fixture.detectChanges();

    spyOn(component, 'ngOnInit').and.callThrough();
    component.ngOnInit();
    expect(component.ngOnInit).toHaveBeenCalled();

Testing Angular Pipes using Jasmine:

Eg: sort.pipe.spec.ts
    const pipe = new SortPipe();
    const  sortedMobiles = pipe.transform(mobiles,'other');
    expect(sortedMobiles).toEqual(mobiles)
